{{/*
Purpose: V4V (Value for Value) Bitcoin payment page

Features:
- Amount selection (500, 1000, 5000, 10000 sats + custom)
- LNURL-pay QR code generation via esm.sh/qrcode
- Invoice status polling with visual feedback
- Payment confirmation with success message
- Error handling with friendly messages
- Session storage for payment state recovery
- Mobile-responsive design

Page Modes:
- General /v4v/ (no essay context) - used from footer link
- Per-essay /essay-slug/v4v/ (with essay_slug, essay_title params from content adapter)

API Endpoints:
- /.well-known/lnurlp/sats - LNURL-pay endpoint (edge function)
- /lnurl-callback - Invoice generation (serverless function)
- /invoice-status - Payment status polling (serverless function)

JavaScript State:
- selectedAmount, currentInvoice, paymentHash
- pollTimer, startTime, isGenerating
- maxSendable, pollFailures

Session Storage:
- Key: v4v_payment_state_{essaySlug} (or v4v_payment_state_general)
- Persists: invoice, hash, amount, startTime
- Enables payment recovery after app switching on mobile

CSS Structure:
- Uses design tokens exclusively (--space-*, --font-*, --text-*, --brand-orange)
- Responsive breakpoint at 600px
- Card styles via .v4v-card class
- Button styles via .btn-ghost class

Important Notes:
- QR library loaded from esm.sh CDN (no build step)
- Polling runs every 3s for up to 5 minutes
- Tab visibility API pauses/resumes polling
- No external CSS or JS files - all inline for simplicity
*/}}

{{ define "main" }}
{{ $essaySlug := .Params.essay_slug | default "" }}
{{ $essayTitle := .Params.essay_title | default "" }}
{{ $hasEssay := ne $essaySlug "" }}

<article class="v4v-page">
  <div class="v4v-content">
    <p class="v4v-intro">
      {{ if $hasEssay }}Pay what it was worth.{{ else }}Support this work.{{ end }}
    </p>

    <!-- Amount Selection (replaced by QR when amount selected) -->
    <div id="amount-selection" class="amount-selection">
      <div class="amount-grid">
        <button class="amount-btn" data-amount="500">500 sats</button>
        <button class="amount-btn amount-btn--suggested" data-amount="1000">1,000 sats</button>
        <button class="amount-btn" data-amount="5000">5,000 sats</button>
        <button class="amount-btn" data-amount="10000">10,000 sats</button>
      </div>

      <div class="custom-amount-section">
        <label for="custom-sats" class="custom-amount-label">Custom amount:</label>
        <div class="custom-amount-field">
          <input
            type="text"
            id="custom-sats"
            class="custom-amount-input"
            placeholder="sats"
            inputmode="numeric"
          />
          <button id="generate-custom" class="btn-ghost custom-amount-btn" type="button">Pay</button>
        </div>
        <p id="validation-error" class="validation-error hidden"></p>
      </div>
    </div>

    <!-- Error Display (card style matching QR display) -->
    <div id="error-display" class="v4v-card error-display hidden">
      <p id="error-message" class="error-message"></p>
      <button id="error-dismiss-btn" class="btn-ghost" type="button">Try again</button>
    </div>

    <!-- QR Display (replaces amount selection) -->
    <div id="qr-display" class="v4v-card qr-display hidden">
      <a id="qr-link" href="#" class="qr-link">
        <div id="qr-code" class="qr-code"></div>
      </a>
      <div id="qr-details" class="qr-details hidden">
        <p class="qr-hint">
          <span class="qr-hint--mobile">Tap to open wallet or <button id="copy-invoice" class="qr-copy-link" type="button">copy invoice</button></span>
          <span class="qr-hint--desktop">Scan with Lightning wallet or <button id="copy-invoice-desktop" class="qr-copy-link" type="button">copy invoice</button></span>
        </p>
        <p class="qr-amount">
          <span id="selected-amount" class="qr-amount-value"></span> sats
        </p>
        <p id="polling-status" class="polling-status">Waiting for payment...</p>
        <button id="cancel-btn" class="btn-ghost" type="button">Cancel</button>
      </div>
    </div>

    <!-- Payment Status (hidden by default) -->
    <div id="payment-status" class="v4v-card payment-status hidden">
      <p class="payment-check"><span id="confirmed-amount"></span> sats received</p>
      <p class="payment-thanks">Thank you for supporting this work.</p>
    </div>

    {{ if $hasEssay }}
    <nav class="essay-nav">
      <a href="/{{ $essaySlug }}/" class="all-essays"><span aria-hidden="true">←</span> Back to essay</a>
    </nav>
    {{ end }}

    <!-- V4V Info -->
    <details class="v4v-details">
      <summary>New to value for value?</summary>
      <p>
        Value for value means no paywalls, no tracking, no platform cut. You read first, decide what the work is worth, then pay directly. Bitcoin makes this possible—no middlemen, no surveillance, just creator and reader.
      </p>
      <p>
        {{ if $hasEssay }}If this essay saved you time or changed your thinking, support it.{{ else }}If this work has helped you, support it.{{ end }}
      </p>
      <a href="https://value4value.info/" class="cta-link"><span class="link-text">How V4V works</span> <span aria-hidden="true">→</span></a>
    </details>
  </div>
</article>

<script type="module">
import QRCode from 'https://esm.sh/qrcode@1.5.3';

// Configuration
const essaySlug = "{{ $essaySlug }}";
const essayTitle = "{{ $essayTitle }}";
const config = {
  lnurlEndpoint: '/.well-known/lnurlp/sats',
  pollInterval: 3000,
  pollTimeout: 300000,
  maxPollFailures: 3,
  qrWidth: 300,
  qrMargin: 2,
};

// State
let state = {
  selectedAmount: null,
  currentInvoice: null,
  paymentHash: null,
  pollTimer: null,
  startTime: null,
  isGenerating: false,
  maxSendable: null,
  pollFailures: 0,
};

// Persist state to sessionStorage (survives mobile app switching)
// Include essay slug in key so each V4V page has its own state
const STORAGE_KEY = `v4v_payment_state_${essaySlug || 'general'}`;

function savePaymentState() {
  const persistedState = {
    selectedAmount: state.selectedAmount,
    currentInvoice: state.currentInvoice,
    paymentHash: state.paymentHash,
    startTime: state.startTime,
  };
  sessionStorage.setItem(STORAGE_KEY, JSON.stringify(persistedState));
}

function loadPaymentState() {
  try {
    const saved = sessionStorage.getItem(STORAGE_KEY);
    if (saved) {
      return JSON.parse(saved);
    }
  } catch (e) {
    console.error('Failed to load payment state:', e);
  }
  return null;
}

function clearPaymentState() {
  sessionStorage.removeItem(STORAGE_KEY);
}

// DOM elements
const elements = {
  amountSelection: document.getElementById('amount-selection'),
  amountBtns: document.querySelectorAll('.amount-btn'),
  customInput: document.getElementById('custom-sats'),
  generateBtn: document.getElementById('generate-custom'),
  validationError: document.getElementById('validation-error'),
  qrDisplay: document.getElementById('qr-display'),
  qrCode: document.getElementById('qr-code'),
  qrLink: document.getElementById('qr-link'),
  qrDetails: document.getElementById('qr-details'),
  copyBtns: document.querySelectorAll('.qr-copy-link'),
  amountDisplay: document.getElementById('selected-amount'),
  cancelBtn: document.getElementById('cancel-btn'),
  paymentStatus: document.getElementById('payment-status'),
  confirmedAmount: document.getElementById('confirmed-amount'),
  errorDisplay: document.getElementById('error-display'),
  errorMessage: document.getElementById('error-message'),
  errorDismissBtn: document.getElementById('error-dismiss-btn'),
};

// Inline validation error (shown near input)
function showValidationError(message) {
  elements.validationError.textContent = message;
  elements.validationError.classList.remove('hidden');
}

function hideValidationError() {
  elements.validationError.classList.add('hidden');
  elements.validationError.textContent = '';
}

// Card error (replaces amount selection, used for generation failures)
function showError(message) {
  elements.errorMessage.textContent = message;
  elements.amountSelection.classList.add('hidden');
  elements.qrDisplay.classList.add('hidden');
  elements.errorDisplay.classList.remove('hidden');
}

function hideError() {
  elements.errorDisplay.classList.add('hidden');
  elements.errorMessage.textContent = '';
  elements.amountSelection.classList.remove('hidden');
}

function getFriendlyError(error) {
  const msg = error.message || '';

  // HTTP status codes
  if (msg.includes('404')) {
    return 'Payment service temporarily unavailable.';
  }
  if (msg.match(/50[0-3]/) || msg.includes('502') || msg.includes('503')) {
    return 'Payment service is experiencing issues.';
  }

  // Network errors
  if (error.name === 'TypeError' || msg.includes('fetch') || msg.includes('network')) {
    return 'Unable to connect. Check your internet connection.';
  }

  // Amount range errors - keep as-is (already user-friendly)
  if (msg.includes('Amount must be between')) {
    return msg;
  }

  // LNURL/Invoice errors with a reason - pass through (usually human-readable from provider)
  if (msg && !msg.includes('request failed') && !msg.includes('error')) {
    return msg;
  }

  // Generic fallback
  return 'Something went wrong.';
}

async function checkInvoiceStatus(hash, invoice) {
  const params = new URLSearchParams();
  if (hash) params.set('hash', hash);
  if (invoice) params.set('invoice', invoice);
  const response = await fetch(`/invoice-status?${params.toString()}`);
  return response.json();
}

async function generateInvoice(sats) {
  try {
    // Cache-bust to ensure fresh invoice each time
    const cacheBust = Date.now();
    const lnurlUrl = essaySlug
      ? `${config.lnurlEndpoint}?essay=${encodeURIComponent(essaySlug)}&title=${encodeURIComponent(essayTitle)}&_=${cacheBust}`
      : `${config.lnurlEndpoint}?_=${cacheBust}`;
    const lnurlResponse = await fetch(lnurlUrl, { cache: 'no-store' });

    if (!lnurlResponse.ok) {
      throw new Error(`LNURL request failed: ${lnurlResponse.status}`);
    }

    const lnurlData = await lnurlResponse.json();

    if (lnurlData.status === 'ERROR') {
      throw new Error(lnurlData.reason || 'LNURL error');
    }

    // Store max amount for client-side validation
    state.maxSendable = lnurlData.maxSendable / 1000;

    const amount = sats * 1000;

    if (amount < lnurlData.minSendable || amount > lnurlData.maxSendable) {
      throw new Error(`Amount must be between ${lnurlData.minSendable / 1000} and ${lnurlData.maxSendable / 1000} sats`);
    }

    const callbackUrl = new URL(lnurlData.callback);
    callbackUrl.searchParams.set('amount', amount);
    callbackUrl.searchParams.set('_', cacheBust);

    const invoiceResponse = await fetch(callbackUrl.toString(), { cache: 'no-store' });

    if (!invoiceResponse.ok) {
      throw new Error(`Invoice request failed: ${invoiceResponse.status}`);
    }

    const invoiceData = await invoiceResponse.json();

    if (invoiceData.status === 'ERROR') {
      throw new Error(invoiceData.reason || 'Invoice generation error');
    }

    return {
      invoice: invoiceData.pr,
      paymentHash: invoiceData.paymentHash
    };

  } catch (error) {
    console.error('Invoice generation failed:', error);
    showError(getFriendlyError(error));
    return null;
  }
}

function displayLoadingState() {
  removeSuggestedHighlight();
  hideValidationError();
  elements.amountSelection.classList.add('hidden');
  elements.qrCode.innerHTML = '<p class="qr-loading">Generating invoice...</p>';
  elements.qrDisplay.classList.remove('hidden');
}

async function renderQRCode(invoice) {
  elements.qrCode.innerHTML = '';
  const canvas = document.createElement('canvas');
  elements.qrCode.appendChild(canvas);

  await QRCode.toCanvas(canvas, invoice.toUpperCase(), {
    width: config.qrWidth,
    margin: config.qrMargin,
    color: { dark: '#000000', light: '#FFFFFF' },
    errorCorrectionLevel: 'M'
  });
}

function displayQRSuccess(sats, invoice) {
  elements.amountDisplay.textContent = sats.toLocaleString();
  elements.qrLink.href = `lightning:${invoice}`;
  elements.qrDetails.classList.remove('hidden');
  state.isGenerating = false;
  startPaymentPolling();
}

async function showQR(sats) {
  if (state.isGenerating) return;
  state.isGenerating = true;
  state.selectedAmount = sats;

  displayLoadingState();

  const result = await generateInvoice(sats);
  if (!result) {
    state.isGenerating = false;
    return;
  }

  state.currentInvoice = result.invoice;
  state.paymentHash = result.paymentHash;

  try {
    await renderQRCode(result.invoice);
  } catch (error) {
    console.error('QR generation failed:', error);
    elements.qrCode.innerHTML = '<p class="qr-loading">QR code generation failed</p>';
    state.isGenerating = false;
    return;
  }

  displayQRSuccess(sats, result.invoice);
}

function startPaymentPolling() {
  if (!state.startTime) {
    state.startTime = Date.now();
  }
  if (state.pollTimer) {
    clearInterval(state.pollTimer);
  }

  if (!state.paymentHash) {
    console.warn('No payment hash available for polling');
    return;
  }

  // Persist state for mobile app switching
  savePaymentState();

  state.pollTimer = setInterval(async () => {
    // Stop polling after timeout
    if (Date.now() - state.startTime > config.pollTimeout) {
      stopPaymentPolling();
      return;
    }

    try {
      const data = await checkInvoiceStatus(state.paymentHash, state.currentInvoice);
      state.pollFailures = 0; // Reset on successful response
      if (data.paid) {
        stopPaymentPolling();
        showPaymentConfirmation();
      }
    } catch (error) {
      console.error('Payment status check failed:', error);
      state.pollFailures++;
      if (state.pollFailures >= config.maxPollFailures) {
        showError('Payment check failed. Retrying...');
        state.pollFailures = 0;
      }
    }
  }, config.pollInterval);
}

function showPaymentConfirmation() {
  clearPaymentState();
  elements.confirmedAmount.textContent = state.selectedAmount.toLocaleString();
  elements.qrDisplay.classList.add('hidden');
  elements.paymentStatus.classList.remove('hidden');
}

function stopPaymentPolling() {
  if (state.pollTimer) {
    clearInterval(state.pollTimer);
    state.pollTimer = null;
  }
}

function resetState() {
  clearPaymentState();
  state.selectedAmount = null;
  state.currentInvoice = null;
  state.paymentHash = null;
  state.startTime = null;
  state.isGenerating = false;
  state.maxSendable = null;
  state.pollFailures = 0;
}

function resetToAmountSelection() {
  stopPaymentPolling();
  resetState();
  hideValidationError();
  elements.qrDisplay.classList.add('hidden');
  elements.qrDetails.classList.add('hidden');
  elements.paymentStatus.classList.add('hidden');
  elements.errorDisplay.classList.add('hidden');
  elements.amountSelection.classList.remove('hidden');
  elements.customInput.value = '';
}

function parseAmount(value) {
  const stripped = value.replace(/,/g, '');
  const parsed = parseInt(stripped, 10);
  if (isNaN(parsed) || parsed <= 0 || parsed > Number.MAX_SAFE_INTEGER) {
    return null;
  }
  return parsed;
}

elements.amountBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const amount = parseInt(btn.dataset.amount, 10);
    showQR(amount);
  });
});

elements.generateBtn.addEventListener('click', () => {
  hideValidationError();
  const amount = parseAmount(elements.customInput.value);
  if (amount === null) {
    showValidationError('Please enter a valid amount in satoshis');
    elements.customInput.focus();
    return;
  }
  // Client-side validation against max amount (if known)
  if (state.maxSendable && amount > state.maxSendable) {
    showValidationError(`Amount cannot exceed ${state.maxSendable.toLocaleString()} sats`);
    elements.customInput.focus();
    return;
  }
  showQR(amount);
});

elements.customInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    e.preventDefault();
    elements.generateBtn.click();
  }
});

elements.customInput.addEventListener('input', (e) => {
  const raw = e.target.value.replace(/[^\d]/g, '');
  if (!raw) {
    e.target.value = '';
    return;
  }
  e.target.value = parseInt(raw, 10).toLocaleString();
});

// Remove suggested highlight on actual selection (not hover)
function removeSuggestedHighlight() {
  document.querySelector('.amount-btn--suggested')?.classList.remove('amount-btn--suggested');
}

elements.copyBtns.forEach(btn => {
  btn.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(state.currentInvoice);
      const originalText = btn.textContent;
      btn.textContent = 'copied';
      setTimeout(() => btn.textContent = originalText, 2000);
    } catch (err) {
      console.error('Copy failed:', err);
    }
  });
});

elements.cancelBtn.addEventListener('click', () => {
  resetToAmountSelection();
});

elements.errorDismissBtn.addEventListener('click', () => {
  hideError();
});

window.addEventListener('beforeunload', () => {
  stopPaymentPolling();
});

// Pause polling when tab is hidden
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopPaymentPolling();
  } else if (state.paymentHash && !state.pollTimer) {
    // Resume polling if we have an active invoice
    startPaymentPolling();
  }
});

// Restore state on page load (for mobile app switching)
(async function restorePaymentState() {
  const saved = loadPaymentState();
  if (!saved || !saved.paymentHash) {
    // No saved state - ensure clean slate
    clearPaymentState();
    return;
  }

  // Check if the saved state has timed out
  const elapsed = Date.now() - saved.startTime;
  if (elapsed > config.pollTimeout) {
    clearPaymentState();
    return;
  }

  // Restore state
  state.selectedAmount = saved.selectedAmount;
  state.currentInvoice = saved.currentInvoice;
  state.paymentHash = saved.paymentHash;
  state.startTime = saved.startTime;

  // Show checking UI
  elements.amountSelection.classList.add('hidden');
  elements.qrCode.innerHTML = '<p class="qr-loading">Checking payment...</p>';
  elements.qrDetails.classList.add('hidden');
  elements.qrDisplay.classList.remove('hidden');

  // Check if already paid before resuming
  try {
    const data = await checkInvoiceStatus(saved.paymentHash, saved.currentInvoice);
    if (data.paid) {
      showPaymentConfirmation();
      return;
    }
  } catch (e) {
    console.error('Payment check failed:', e);
  }

  // Not paid yet - restore full UI and resume polling
  elements.amountDisplay.textContent = saved.selectedAmount.toLocaleString();
  elements.qrLink.href = `lightning:${saved.currentInvoice}`;
  elements.qrCode.innerHTML = '<p class="qr-loading polling">Waiting for payment...</p>';
  elements.qrDetails.classList.remove('hidden');
  startPaymentPolling();
})();
</script>

<style>
.v4v-page {
  max-width: var(--content-max-width);
  margin: 0 auto;
}

.v4v-content {
  margin-top: var(--space-md);
}

.v4v-intro {
  font-size: var(--font-lg);
  color: var(--text-secondary);
  margin-bottom: var(--space-xl);
  line-height: var(--line-height-body);
}

.amount-selection {
  margin-bottom: var(--space-xl);
}

.amount-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: var(--space-md);
  margin-bottom: var(--space-md);
}

.amount-btn {
  padding: var(--space-lg);
  background: transparent;
  border: var(--border-width-emphasis) solid var(--border-color);
  border-radius: var(--border-radius-interactive);
  cursor: pointer;
  font-family: var(--font-system);
  font-size: var(--font-xl);
  font-weight: var(--font-weight-semibold);
  font-variant-numeric: tabular-nums;
  color: var(--text-primary);
  transition: all var(--transition-fast);
}

.amount-btn:hover {
  border-color: var(--brand-orange);
  color: var(--brand-orange);
}

.amount-btn:active {
  transform: translateY(1px);
}

.amount-btn--suggested {
  border-color: var(--brand-orange);
  color: var(--brand-orange);
}

.amount-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.amount-btn:disabled:hover {
  border-color: var(--border-color);
  color: var(--text-primary);
}

.amount-btn--suggested:disabled {
  border-color: var(--brand-orange);
  color: var(--brand-orange);
}

.custom-amount-label {
  display: block;
  font-size: var(--font-sm);
  color: var(--text-meta);
  margin-bottom: var(--space-sm);
  font-weight: var(--font-weight-normal);
}

.custom-amount-field {
  display: flex;
  gap: var(--space-sm);
  align-items: stretch;
}

.custom-amount-input {
  padding: var(--space-xs) 0;
  border: none;
  border-bottom: var(--border-width) solid var(--border-color);
  border-radius: 0;
  font-family: var(--font-system);
  font-size: var(--font-base);
  background: var(--background-body);
  color: var(--text-primary);
  width: calc((100% - 3 * var(--space-sm)) / 4);
  text-align: right;
  transition: border-color var(--transition-fast);
}

.custom-amount-input:focus {
  outline: none;
  border-bottom-color: var(--brand-orange);
}

.custom-amount-input::placeholder {
  color: var(--text-meta);
  opacity: 0.5;
}

/* Ghost button base - used for secondary actions */
.btn-ghost {
  background: none;
  border: var(--border-width) solid var(--text-meta);
  border-radius: var(--border-radius-interactive);
  color: var(--text-meta);
  cursor: pointer;
  font-family: var(--font-system);
  font-size: var(--font-sm);
  font-weight: var(--font-weight-medium);
  padding: var(--space-xs) var(--space-md);
  transition: all var(--transition-fast);
}

.btn-ghost:hover {
  border-color: var(--brand-orange);
  color: var(--brand-orange);
}

.btn-ghost:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.btn-ghost:disabled:hover {
  border-color: var(--text-meta);
  color: var(--text-meta);
}

/* Custom amount button overrides */
.custom-amount-btn {
  padding: var(--space-sm) var(--space-md);
  white-space: nowrap;
  flex-shrink: 0;
}

.custom-amount-btn:active {
  transform: translateY(1px);
}

.custom-amount-input:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.validation-error {
  color: var(--brand-orange);
  font-size: var(--font-sm);
  margin-top: var(--space-sm);
  margin-bottom: 0;
}

/* Card base - used for QR, error, and payment status displays */
.v4v-card {
  text-align: center;
  padding: var(--space-xl);
  background: var(--background-card);
  border-radius: var(--border-radius-md);
  margin-bottom: var(--space-lg);
  animation: fadeIn var(--transition-base) ease-out;
}

.qr-display {
  transition: background-color var(--transition-fast);
}

/* .error-display uses .v4v-card base */

.error-display .error-message {
  color: var(--brand-orange);
  font-size: var(--font-base);
  margin-bottom: var(--space-lg);
}

/* .error-dismiss-btn uses .btn-ghost base */

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.qr-code {
  min-height: var(--qr-size);
  display: flex;
  align-items: center;
  justify-content: center;
}

.qr-code:has(canvas) {
  margin-top: var(--space-sm);
  margin-bottom: var(--space-lg);
}

.qr-loading {
  color: var(--text-meta);
  font-size: var(--font-base);
  margin: 0;
  text-decoration: none;
}

.qr-loading.polling {
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.polling-status {
  font-size: var(--font-sm);
  color: var(--text-meta);
  margin-bottom: var(--space-md);
  animation: pulse 2s ease-in-out infinite;
}

.qr-code canvas {
  display: block;
  margin: 0 auto;
  box-shadow: var(--shadow-content-light);
  transition: box-shadow var(--transition-fast);
}

a.qr-link,
a.qr-link:hover {
  display: block;
  cursor: pointer;
  text-decoration: none;
}

.qr-link:hover .qr-code canvas {
  box-shadow: 0 0 0 3px var(--brand-orange);
}

.qr-hint {
  font-size: var(--font-sm);
  color: var(--text-meta);
  margin-bottom: var(--space-md);
}

.qr-hint--mobile {
  display: inline;
}

.qr-hint--desktop {
  display: none;
}

@media (min-width: 768px) {
  .qr-hint--mobile {
    display: none;
  }
  .qr-hint--desktop {
    display: inline;
  }
}

.qr-amount {
  font-size: var(--font-2xl);
  font-weight: var(--font-weight-bold);
  color: var(--text-primary);
  margin-bottom: var(--space-xs);
  letter-spacing: var(--letter-spacing-tight-md);
}

.qr-amount-value {
  font-variant-numeric: tabular-nums;
}

.qr-copy-link {
  background: none;
  border: none;
  color: var(--text-meta);
  cursor: pointer;
  font-family: inherit;
  font-size: inherit;
  font-weight: var(--font-weight-normal);
  text-decoration: underline;
  padding: 0;
  transition: color var(--transition-fast);
}

.qr-copy-link:hover {
  color: var(--brand-orange);
}

/* .payment-status uses .v4v-card base */
.payment-status {
  padding: var(--space-2xl);
  margin-bottom: var(--space-xl);
  transition: background-color var(--transition-fast);
}

.payment-check {
  font-size: var(--font-2xl);
  font-weight: var(--font-weight-semibold);
  color: var(--brand-orange);
  margin-bottom: var(--space-sm);
  letter-spacing: var(--letter-spacing-tight-md);
}

.payment-thanks {
  color: var(--text-secondary);
  font-size: var(--font-base);
  margin-bottom: 0;
}

.v4v-page .essay-nav {
  margin-top: var(--space-md);
}

.v4v-details {
  margin-top: var(--space-lg);
}

.v4v-details summary {
  cursor: pointer;
  font-size: var(--font-base);
  color: var(--text-meta);
  font-weight: var(--font-weight-medium);
  transition: color var(--transition-fast);
  list-style-position: outside;
  list-style: none;
}

.v4v-details summary::marker {
  display: none;
}

.v4v-details summary:hover {
  color: var(--brand-orange);
}

.v4v-details p {
  margin-top: var(--space-md);
  font-size: var(--font-base);
  color: var(--text-secondary);
  line-height: var(--line-height-body);
}

.v4v-details p:last-child {
  margin-bottom: 0;
}

.hidden {
  display: none;
}

@media (max-width: 600px) {
  .custom-amount-input {
    max-width: none;
  }

  .qr-display,
  .payment-status {
    padding: var(--space-xl);
  }

  /* !important required to override inline styles from QR library */
  .qr-code canvas {
    width: var(--qr-size) !important;
    height: var(--qr-size) !important;
  }
}
</style>
{{ end }}
